
1.
Part3까지 우리는 디자인과 코드의 간극을 줄이기 위한 기술적인 내용들 알아보았습니다.
Part4에서는 본격적으로 개발자와 협업을 하기 위한 실무적인 내용들에 대해 알아볼텐데요

첫번째로, 많은 디자이너들이 들어는 보았지만, 막연히 어렵게 느끼는 Git에 대해 다뤄보도록 하겠습니다.


2.
제품을 만들다보면 이런 말을 하게 될때가 있죠.

"이전 버전으로 되돌릴 수 있을까요?"
"이번에 작업한 기능은 언제 사용자가 쓸 수 있나요?"
"디자인 변경사항이 반영되지 않은 것 같아요!"

바로 이런 버전관리와 배포를 위한 시스템이 git이라고 할 수 있어요.


3.
그렇다면 디자이너가 왜 git에 대해 알아야할까요?

디자이너가 Git과 브랜치 구조를  사용하는 게 아니라 "이해만" 해도 협업 효율이 확연히 달라집니다. 
개발자가 기대하는 **“작업 단위 사고방식”** 을 공유하게 되기 때문이에요.

현재 배포가 어떻게 이루어지고 있는지 알면, 
디자이너가 개발 결과물에 대해 언제 피드백을 하면 좋을지 감을 잡기 쉽습니다.

그리고 이슈에 대해 정확한 시점과 지점을 특정하여 전달할 수 있게됨으로써
개발자가 디자이너의 요구사항을 파악하기 더 쉬워지죠.

이를 응용하면 A/B테스트와 같이 여러 버전을 테스트해보아야 할때,
테스트 시나리오 논의 단계에서부터 더 적극적으로 논의할 수 있게 됩니다.

그리고 위와 같은 내용들을 가지고 개발자와 소통할때, 서로 각자의 언어로 이야기하는게 아니라
통일된 하나의 언어로 소통함으로써 오해를 줄일 수 있게 되는 것은 당연하구요.


4.
그렇다면 git이 정확히 무엇인지부터 알아봐야겠죠?

git은 바로 버전 관리 시스템 (version control system)입니다. 말 그대로 파일의 변경 이력을 시간 순서대로 차곡차곡 기록해서, 언제든 원하는 시점의 버전으로 돌아가 다시 작업할 수 있게 해주는 역할을 합니다.

이미지 작업이나 문서 작업을 하다가 숱하게 겪고, 밈으로도 많이 활용되는 소재 있죠?
최종, 최최종, 최최종-2, 최최종-확정...
결과물을 버전에 따라 계속 새롭게 따로 저장하게되면 위와같은 카오스가 생기게 됩니다.
이런 카오스를 막기 위해 등장한 것이 바로 git이라고 할 수 있죠.

5.
git의 핵심 개념은 repository와 commit, 그리고 branch입니다.

각 개념에 대해 하나씩 알아보도록 하죠.


6.
먼저, Repository는 내가 관리하려는 프로젝트의 모든 파일과 그 변경 이력을 담아두는 폴더입니다.
내 컴퓨터에 있는 '로컬 저장소'와, github이나 gitlab같은 서버에 있어서 팀원들과 공유할 수 있는 '원격 저장소'로 나누어집니다. 로컬 저장소에 있는 변경사항을 원격 저장소와 동기화시킴으로써 팀원들이 각자의 로컬 저장소를 갖고 있으면서도 서로 작업을 공유할 수 있게 되죠.

7.
다음으로 Commit은 특정 시점의 파일 상태를 사진 찍듯이 저장하는 행위입니다. 디자인의 의미 있는 변화가 끝났을 때 '로그인 버튼 추가', '타이포그래피 간격 수정'같은 메세지와 함께 커밋을 남깁니다. 이 커밋들이 모여 프로젝트의 history가 되는거죠.

8.
마지막으로 branch는 말 그대로 '나뭇가지'입니다. 하나의 메인 줄기에서 여러 갈래로 뻗어나가는 것처럼, 기존의 안정적인 코드를 그대로 둔 채, 새로운 기능 개발이나 실험적인 시도를 하기 위한 독립적인 작업 공간을 만드는 겁니다. 

조금 복잡해 보이지만 이런 브랜치 단위의 작업 방식을 사용함으로써, 작업을 효율적으로 나누고 관리할 수 있게 됩니다. 

9.
예를 들어서 로그인 기능과 결제 기능을 동시에 개발한다고 했을때, 개발자 A는 로그인 브랜치에서 작업을 하고 개발자 B는 결제 브랜치에서 각각 작업한 후 메인 브랜치에서 작업을 합치는거죠.

이렇게 각각의 브랜치에서 작업을 하면 메인 브랜치에 있는 코드는 합치기 전까지 안전하게 보호할 수 있습니다.
새로운 기능에서 버그가 생기더라도, 메인 브랜치에는 아무런 영향이 없는거죠.

이렇게 함으로써 각각의 작업 브랜치에서는 마음껏 실험하고 실패할 수 있습니다. "이 디자인 한번 적용해볼까?" 하는 아이디어를 독립된 브랜치에서 시도해보고, 별로면 그냥 그 브랜치를 없애버리면 그만입니다.

10.
그렇다면 이 브랜치라는 것을 어떻게 사용해야 할까요?

Git을 어떻게 사용할까에 대해서는 다양한 전략들이 있지만
가장 보편적으로 널리 쓰이는 GitFlow라는 전략에 대해 소개해드리도록 하겠습니다

GitFlow 브랜치 전략에서는 크게
각각의 역할이 있는 Main, Develop, Feature, Hotfix 4가지 종류의 브랜치를 사용합니다

11.
main 브랜치는 현재 실제 사용자에게 서비스되고 있는
가장 안정적인 버전의 코드가 있는 브랜치를 말합니다. 

Develop 브랜치는 앞으로 배포될 기능들이 개발되고 합쳐지는
최신 개발 버전의 코드가 있는 곳이고요.

그리고 Feature 브랜치는 해당 브랜치에서 개발 중인 기능 이름을 넣어서 브랜치를 만들게 되는데요.
예를 들어서 로그인 기능인 경우 feature 슬래쉬 login (feature/login)과 같이 브랜치 이름을 작성합니다.
경우에 따라서는 이 브랜치 이름에 지라나 리니어 같은 이슈 트래커의 티켓 번호가 붙기도 합니다

마지막으로 Hotfix 브랜치는 Feature 브랜치와 마찬가지로
hotfix/기능 이름의 구조로 브랜치명을 작성해서 사용하는데요

이미 배포된 서비스에서 치명적인 버그가 발생했을 때
긴급하게 수정하기 위한 브랜치입니다


11.
개발자는 일반적으로 이런 방식으로 일을 하게 됩니다.

먼저 Develop 브랜치에서 새로운 Feature 브랜치를 생성합니다.
예를 들면 로그인 페이지를 개발한다고 하면,
Feature 슬래시 로그인 페이지(feature/login-page)라는 새 브랜치를 만들게 되죠

그리고 여기서 로그인 페이지 디자인을 코드로 구현하고 테스트를 합니다.
작업이 끝나면 "로그인 페이지 개발 완료했습니다. 코드 한번 봐주세요" 라는 의미로
풀 리퀘스트 줄여서 PR을 생성합니다. 

풀 리퀘스트란, 내가 작업한 브랜치의 작업 내용을
다른 브랜치에서 pull 즉 끌어와서 적용해달라는 요청을 말합니다.

그렇게 PR을 생성하게 되면 다른 팀원들이 코드를 리뷰하고
"이 부분은 이렇게 수정하면 더 좋겠네요" 와 같은 의견을 남깁니다.

이렇게 리뷰가 끝나고 승인이 나면 이 feature/login-page 브랜치를
develop 브랜치에 merge 즉, 병합 시킵니다.


디자이너가 이 흐름을 이해하면
내 디자인이 지금 어떤 브랜치에서 어떤 작업 상태에 있는지
대략적으로 알 수 있게 되겠죠.

12.
자 이제 Feature 브랜치에서 작업한 코드가
develop 브랜치에 합쳐졌습니다
그럼 바로 사용자들이 볼 수 있을까요?
아닙니다.
몇 가지 중요한 단계를 더 거쳐야 합니다

앞서 이야기한 브랜치가 작업 공간이라면, 실제 작업한 코드가 배포되어있는 환경도 용도에 따라 분리되어 있습니다.

더 다양할수도 있지만, 일반적인 케이스로 말씀드릴게요.

먼저 개발환경입니다. 개발자들이 자신의 컴퓨터에서 코딩하고 테스트하는, 아주 불안정하고 변화가 잦은 환경입니다.

그리고 스테이징 환경이 있는데요. 사용자에게 딜리버리 직전의 최종 테스트를 위한 환경입니다. 실제 서비스와 거의 똑같은 모습을 하고 있죠. QA팀이나 디자이너가 디자인이 제대로 적용되었는지, 기능이 제대로 동작하는지 마지막으로 검수하는 곳이 바로 스테이징 환경입니다.

마지막으로 프로덕션 환경. 바로 지금, 실제 사용자들이 접속해서 사용하고 있는 진짜 서비스 환경입니다. 라이브 환경이라도고 하죠.


13.
개발이 완료된 기능은 CI/CD (continuous integration and continuous deployment) 
라는 자동화된 파이프라인을 통해 먼저 스테이징 환경에 배포됩니다. 

이때가 바로 디자이너가 투입될 타이밍입니다.

스테이징 서버의 주소를 받아서, 다양한 기기와 브라우저에서
디자인이 의도대로 구현되었는지 꼼꼼하게 확인해야 합니다.

픽셀 하나가 틀어진 것, 폰트가 잘못 적용된 것, 인터렉션이 어색한 것 등
모든 것을 이 단계에서 잡아내야 합니다.

여기서 OK사인이 나야 비로소 안전하게 프로덕션 환경으로 배포될 수 있습니다.


14.
앞에서 이론적으로만 다뤘던 git에 대한 개념들을 한번 직접 다뤄보도록 할게요.

더 진행하기 전에 먼저 github 계정을 확인해보세요.
github에 아직 가입하지 않았다면, 
깃헙 홈페이지 (github.com) 에 접속하여 이번 기회에 계정을 만들어봅시다.

계정을 만들었다면, 이제부터 제가 보여드리는 방법을 보고 따라해보시면 되겠습니다.



--------------------------------------------------
 (여기부터는 화면 녹화)
 
 Github에 로그인하면 Dashboard 화면이 뜰 텐데요. 
 여기서 좌측 사이드바에 new 버튼을 눌러서 repository를 생성해볼게요

생성할 repository의 이름을 입력하고, 간단한 레포지토리에 대한 설명을 작성한 뒤
Create repository 버튼을 눌러 repository를 생성합니다.

그럼 레포지토리 메인 화면이 뜰텐데요.
이제 github이라는 원격 저장소에 레포지토리가 생성된 것입니다.

그렇다면 이 레포지토리를 로컬 저장소로 클론해볼게요.
git과 github을 다루는 방식에는 여러 방법이 있는데요,

개발자들은 CLI툴 즉 명령어를 직접 사용해서 다루는 경우도 많고, 
github desktop이나 sourcetree, gitKraken과 같은 GUI툴을 사용하는 케이스도 있어요.

우리는 이번에 github desktop이라는 툴을 통해서 한번 다뤄보도록 할게요.
google에서 github desktop을 검색해 어플리케이션을 다운받아 설치하도록 합니다.

github desktop을 설치하고 실행시켜보면 온보딩 화면이 뜬는데요,
여기서 clone a repository from the internet을 클릭하고 

github.com이 선택된 상태에서 sign in을 해줍니다.

그럼 내 레포지토리 목록이 뜨게 되는데요, 제껀 좀 많죠?
여기서 방금 생성한 레포지토리를 선택하고 하단에서 클론할 디렉토리 경로를 선택한 뒤 clone을 눌러줍니다.

그럼 로컬에 클론된 레포지토리 화면이 github desktop에 뜨게 되는데요.

상단 메뉴를 보면 현재 레포지토리 이름과 현재 브랜치 정보를 확인할 수 있고요
changes목록은 비어있고, history 항목도 비어있는 걸 볼 수 있어요.

그럼 한번 첫 커밋을 해볼까요?

그럼 이제 저는 code editor를 켜서 readme 파일을 하나 만들어볼게요.
code editor가 없다면 textedit 프로그램이나 메모장을 켜서 아무 txt파일이나 만드셔도 상관없습니다.

이렇게 readme파일을 하나 만들었더니 changes 항목에 뭔가 생겼죠?
파일이 추가되고 추가된 내용이 옆에 표시됩니다.

이제 변경점이 있으니 첫 커밋을 남겨볼게요.

changes 밑에 있는 form을 사용해서 commit을 작성합니다.
commit to main 버튼을 누르면 main 브랜치에 commit을 남기게됩니다.

history탭을 눌러보면 방금 작성한 commit을 볼 수 있죠.
이제 commit을 했으니, 로컬 저장소에 있는 브랜치와 commit들을 원격 저장소에 동기화시켜 봅시다

publish branch 버튼을 누르면 로컬 저장소의 현재 브랜치를 원격 저장소에 동기화됩니다.

잘 동기화되었는지 확인해볼까요? 다시 브라우저를 열어 github의 레포지토리 페이지에 들어가봅시다.
네 readme 파일이 잘 생성되었고, 작성한 내용도 잘 나오는 걸 확인할 수 있죠?

참고로 readme.md 파일을 작성하면 보이는 것과 같이
자동으로 해당 레포지토리에 들어가자마자 readme 문서의 내용이 뜨게 됩니다.

보통 readme문서에는 해당 프로젝트에 대한 소개와 간략한 사용법 등을 적어두는데요
해당 레포지토리를 보는 사람들이 해당 프로젝트에 대해 
빠르게 파악할 수 있도록 하는 문서의 역할을 합니다.

이제 첫 커밋을 해 보았으니, 실무처럼 feature 브랜치를 만들어서 작업해볼까요?

상단에 브랜치 메뉴를 누르고

new branch을 눌러서 현재의 main브랜치로부터 새로운 브랜치를 만듭니다.
저는 feature/login 이라고 만들게요.
branch를 만들면 브랜치 메뉴에 현재 브랜치가 변경된 걸 볼수 있죠?

이번엔 features 폴더를 만들고 그 안에 login폴더를 만든 다음에 
login 기능에 대한 prd문서와 structure 문서를 만들거에요.
대략적인 내용을 작성하고 저장을 하면 github desktop에 변경점이 생긴 걸 확인할 수 있죠?

커밋에 포함할 파일을 선택하고 커밋 메세지를 작성해줍니다.
커밋 메세지 작성에 대한 컨벤션도 회사마다 다른데,
저희 회사 같은 경우는 커밋의 앞머리에 `feat` `fix` `chore` `docs` 와 같은 태그를 붙여서 관리하는 편입니다

이번 커밋은 login feature 관련 문서를 작성했으니 
`[docs] add docs for login feature` 와 같이 작성해볼게요.

커밋을 했으니 아까와 마찬가지로 publish branch를 하여 원격 저장소에 동기화를 시킵니다.

github repository에 가보면 상단에 뭔가 떠있죠?
변경점이 있는 브랜치가 있으니 pull request를 하라는 알림 배너에요.
저 버튼을 눌러서 해도 되지만, 저희는 공부용이니까 메뉴얼하게 한번 해볼게요

먼저 상단 메뉴 중 pull requests 탭을 눌러줍니다. 
이 메뉴는 현재 활성화된 pull request들의 목록을 표시해주는 화면이에요.
여기서 new pull request를 눌러줍니다.

상단에 보면 base 와 compare가 있는데요, 
Compare 브랜치에 있는 커밋이 base 브랜치로 병합된다고 생각하시면 됩니다.
따라서 저희는 base에는 main브랜치를 두고 compare에 feature/login 브랜치를 선택할거에요

그럼 어떤 변경사항이 있는지 하단에 뜨는 것을 확인할 수 있죠.

create pull request버튼을 눌러줍니다.

pull request를 생성하는 화면인데요, 
여기서 pr의 제목과 pr에 담긴 내용에 대한 개요를 작성해줍니다.

보통 개발자들은 여기에 작성한 코드에 대한 대략적인 내용과
테스트코드 작성, 코드 컨벤션 확인 등의 체크리스트 항목들을 체크하여 작성하곤 합니다.

저희는 간단하게 작성하고 넘어가볼게요.

네 이제 pr이 생성되었는데요, 만약 해당 프로젝트에 함께 작업하는 동료가 있다면 우측 reveiwer섹션에서
동료를 선택해 해당 Pr에 대한 review를 요청할 수 있습니다.

저희는 review가 되었다고 가정하고, merge pull request를 해보겠습니다.

merge를 하게되면 이렇게 merged표시가 뜨면서 브랜치 병합이 완료된 걸 알수 있습니다.

직접 확인해볼까요?
code 탭을 눌러서 repository메인 화면으로 나와보면 
메인 브랜치에 아까 feature/login 브랜치에서 만들었던 폴더와 그 안에 문서들이 있는 것을 확인할 수 있죠

자 이제 원격 저장소에서 main 브랜치에 병합을 했으니 로컬 저장소도 병합된 내용을 동기화시켜야겠죠?

github desktop을 열어서 current branch를 main으로 변경해줍니다
그러면 우측 액션이 fetch origin으로 바뀐걸 볼수 있는데요.

해당 버튼을 눌러보면 fetch(불러오기)가 진행되고 완료되면 버튼이 pull origin으로 변합니다.
한번 더 누르면 불러온 내용을 내 로컬 main브랜치에 반영하게 되죠.
history 탭을 눌러보면 병합된 커밋을 확인할 수 있습니다.

자 이렇게 git과 github이 어떻게 작동하고 어떻게 협업하는지 기본적인 구조를 알아봤는데요
직접 해보니 조금 이해가 되시나요?

사실 이런 git과 같은 브랜치 구조는 피그마에서도 지원을 해주고 있어요. (pro 및 org 프라이싱에서 지원)
물론 아무래도 그래픽 기반이다보니 github처럼 라인바이 라인으로 변경점들을 찾아주거나 하는 것은 쉽지 않지만, 기본적인 컨셉은 같은 구조라고 볼 수 있습니다.

git을 디자이너들이 반드시 직접 다뤄야 하는 것은 아니지만, 혹시라도 코드기반으로 협업을 할 기회가 생긴다면, (css를 직접 수정한다던지) 오늘의 내용이 많이 도움이 될거라고 확신합니다.

---------------

다음 시간에는 '최고의 핸드오프 문서 만들기' 실습을 진행합니다. 피그마의 dev mode와 annotation 기능을 적극 활용해서, 어떻게 개발자와 디자이너 모두 이해하기 쉽고 관리할 수 있는 문서를 만들지에 대해 알려드릴게요.

오늘 강의는 여기까지입니다. 수고하셨습니다